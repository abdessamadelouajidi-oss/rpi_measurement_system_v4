"""Main application loop for the Raspberry Pi vibration measurement system."""

import time
import csv
import os
import shutil
import signal
from sensors import Accelerometer, ToFSensor, HallSensor
from config import (
    READING_INTERVAL,
    ACCELEROMETER_I2C_ADDRESS,
    TOF_ENABLED,
    TOF_I2C_ADDRESS,
    HALL_ENABLED,
    HALL_SENSOR_PIN,
    HALL_PULL_UP,
    CSV_OUTPUT_PATH,
    USB_COPY_ANY,
    USB_CHECK_INTERVAL,
)


class MeasurementSystem:
    """Main vibration measurement system coordinator."""

    def __init__(self):
        """Initialize the measurement system."""
        print("=" * 60)
        print("Raspberry Pi Vibration Measurement System")
        print("=" * 60)
        print()

        # Initialize sensor
        print("Initializing accelerometer.")
        self.accelerometer = Accelerometer(i2c_address=ACCELEROMETER_I2C_ADDRESS)
        print()

        self.tof = None
        if TOF_ENABLED:
            print("Initializing VL53L0X ToF sensor.")
            self.tof = ToFSensor(i2c_address=TOF_I2C_ADDRESS)
            print()

        self.hall_sensor = None
        if HALL_ENABLED:
            print("Initializing Hall sensor.")
            self.hall_sensor = HallSensor(
                pin=HALL_SENSOR_PIN,
                pull_up=HALL_PULL_UP,
                poll_hz=800,  # you can raise this if you have very high RPM / many pulses per rev
            )
            print()
            self.hall_sensor.reset_count()

        self.running = True
        self.last_reading_time = 0
        self.readings = []
        self.csv_output_path = CSV_OUTPUT_PATH
        self.usb_copy_any = USB_COPY_ANY
        self.usb_seen_mounts = set()
        self.last_usb_check_time = 0

    def request_shutdown(self, signum=None, _frame=None):
        """Request a clean shutdown (used by SIGTERM/SIGINT)."""
        if signum is not None:
            print(f"\n[SHUTDOWN] Signal {signum} received. Stopping...")
        self.running = False

    def read_vibration(self):
        """Read accelerometer and print vibration data."""
        try:
            accel_data = self.accelerometer.read()
            tof_data = self.tof.read() if self.tof else {"distance_mm": None}
            spin_count = self.hall_sensor.get_count() if self.hall_sensor else 0

            timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
            self.readings.append(
                {
                    "timestamp": timestamp,
                    "x": accel_data["x"],
                    "y": accel_data["y"],
                    "z": accel_data["z"],
                    "distance_mm": tof_data["distance_mm"],
                    "spin_count": spin_count,
                }
            )
            distance_text = (
                f"{tof_data['distance_mm']:.1f}mm"
                if tof_data["distance_mm"] is not None
                else "N/A"
            )
            print(
                f"[{timestamp}] Vibration - "
                f"X={accel_data['x']:+.2f}m/s² "
                f"Y={accel_data['y']:+.2f}m/s² "
                f"Z={accel_data['z']:+.2f}m/s²"
            )
            print(f"[{timestamp}] Spins={spin_count}")
            if self.tof:
                print(f"[{timestamp}] Distance - D={distance_text}")
        except Exception as e:
            print(f"[ERROR] Failed to read accelerometer: {e}")

    def _is_removable_mount(self, device, fstype, mount_point):
        if not device.startswith(("/dev/sd", "/dev/mmcblk")):
            return False
        if fstype not in {"vfat", "exfat", "ext4"}:
            return False
        return mount_point.startswith("/media") or mount_point.startswith("/run/media")

    def _scan_usb_mounts(self):
        """Return all mounted USB paths under /media and /run/media."""
        if not self.usb_copy_any:
            return []

        mounts = set()
        try:
            with open("/proc/mounts", "r") as mounts_file:
                for line in mounts_file:
                    parts = line.split()
                    if len(parts) < 3:
                        continue
                    device, mount_point, fstype = parts[0], parts[1], parts[2]
                    if self._is_removable_mount(device, fstype, mount_point):
                        mounts.add(mount_point)
        except Exception as e:
            print(f"[USB] Failed to scan mounts: {e}")
        return sorted(mounts)

    def _build_usb_csv_path(self, mount_path):
        """Build a timestamped CSV path on the USB drive."""
        base = os.path.splitext(os.path.basename(self.csv_output_path))[0]
        stamp = time.strftime("%Y%m%d_%H%M%S")
        return os.path.join(mount_path, f"{base}_{stamp}.csv")

    def _copy_csv_to_mounts(self, mount_paths):
        """Copy the latest CSV to one or more USB mount paths."""
        if not self.readings:
            print("[USB] No readings to copy yet.")
            return

     #   self.save_readings_to_csv()

        success = False
        for mount_path in mount_paths:
            try:
                usb_csv_path = self._build_usb_csv_path(mount_path)
                shutil.copy2(self.csv_output_path, usb_csv_path)
                print(f"[USB] Copied CSV to {usb_csv_path}")
                success = True
            except Exception as e:
                print(f"[USB] Copy failed for {mount_path}: {e}")

        if not success:
            print("[USB] No copies succeeded.")

    def _check_usb_copy(self):
        """Detect USB insertion/removal and copy CSV when inserted."""
        mounts = set(self._scan_usb_mounts())
        new_mounts = mounts - self.usb_seen_mounts

        if new_mounts:
            self._copy_csv_to_mounts(sorted(new_mounts))

        self.usb_seen_mounts = mounts

    def run(self):
        """Main application loop."""
        signal.signal(signal.SIGTERM, self.request_shutdown)
        signal.signal(signal.SIGINT, self.request_shutdown)

        print("System started. Running continuously.")
        print("Stop the service or press Ctrl+C to stop and save.")
        print("-" * 60)
        print()

        try:
            while self.running:
                current_time = time.time()
                if current_time - self.last_reading_time >= READING_INTERVAL:
                    self.read_vibration()
                    self.last_reading_time = current_time

                if current_time - self.last_usb_check_time >= USB_CHECK_INTERVAL:
                    self.last_usb_check_time = current_time
                    self._check_usb_copy()

                time.sleep(0.05)

        except KeyboardInterrupt:
            print("\n\nKeyboard interrupt received.")
            self.request_shutdown()

        finally:
            self.cleanup()

    def save_readings_to_csv(self):
        """Save collected readings to a CSV file after shutdown."""
        if not self.readings:
            print("[CSV] No readings to save.")
            return

        try:
            with open(self.csv_output_path, "w", newline="") as csv_file:
                writer = csv.DictWriter(
                    csv_file,
                    fieldnames=["timestamp", "x", "y", "z", "distance_mm", "spin_count"],
                )
                writer.writeheader()
                writer.writerows(self.readings)
            print(f"[CSV] Saved {len(self.readings)} readings to {self.csv_output_path}")
        except Exception as e:
            print(f"[CSV] Failed to write CSV file: {e}")

    def cleanup(self):
        """Clean up GPIO and other resources."""
        print("Cleaning up...")
        if self.hall_sensor:
            self.hall_sensor.cleanup()
        try:
            import RPi.GPIO as GPIO
            GPIO.cleanup()
            print("GPIO cleanup complete.")
        except Exception:
            pass

        self.save_readings_to_csv()
        if self.hall_sensor:
            self.hall_sensor.reset_count()

        print("=" * 60)
        print("System shutdown complete.")
        print("=" * 60)


def main():
    """Entry point."""
    system = MeasurementSystem()
    system.run()


if __name__ == "__main__":
    main()
